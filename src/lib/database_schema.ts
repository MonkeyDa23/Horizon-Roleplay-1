// FIX: Wrapped the entire file content in a template literal to treat it as a string,
// preventing the TypeScript compiler from trying to parse SQL as TypeScript code.
export const databaseSchema = `
/*
====================================================================================================
 Vixel Roleplay Website - Full Database Schema (V2 - Robust Auth Fix)
 Author: AI
 Date: 2024-05-24
 
 INSTRUCTIONS:
 1. Go to your Supabase Project Dashboard.
 2. Navigate to the "SQL Editor".
 3. Click "+ New query".
 4. Copy the ENTIRE content of this file.
 5. Paste it into the SQL Editor.
 6. Click "RUN".
 
 This script is idempotent, meaning it can be run multiple times safely. It will create tables
 if they don't exist and will not throw errors on subsequent runs.
====================================================================================================
*/

-- =================================================================
-- PRE-FLIGHT PERMISSION FIX
-- =================================================================
-- This command ensures the 'postgres' user, which runs this script in the Supabase SQL Editor,
-- has the necessary permissions to create tables and other objects within the 'public' schema.
-- This resolves the "permission denied for schema public" error.
GRANT USAGE, CREATE ON SCHEMA public TO postgres;


-- =================================================================
-- 1. EXTENSIONS & INITIAL SETUP
-- =================================================================
-- Enable the HTTP extension if it's not already enabled, for calling webhooks.
create extension if not exists http with schema extensions;

-- Enable the pg_graphql extension for potential future GraphQL use.
create extension if not exists pg_graphql with schema extensions;

-- =================================================================
-- 2. TABLE DEFINITIONS
-- =================================================================

-- Table for storing site-wide configuration settings.
create table if not exists public.config (
    id smallint primary key default 1,
    "COMMUNITY_NAME" text not null default 'Vixel Roleplay',
    "LOGO_URL" text,
    "DISCORD_GUILD_ID" text,
    "DISCORD_INVITE_URL" text,
    "MTA_SERVER_URL" text,
    "BACKGROUND_IMAGE_URL" text,
    "SHOW_HEALTH_CHECK" boolean default false,
    "SUBMISSIONS_CHANNEL_ID" text,
    "AUDIT_LOG_CHANNEL_ID" text,
    constraint id_check check (id = 1)
);
-- Ensure there's always a row to update.
insert into public.config (id) values (1) on conflict (id) do nothing;


-- Table for storing user profiles, synced with Discord data.
create table if not exists public.profiles (
    id uuid primary key references auth.users(id) on delete cascade,
    discord_id text not null unique,
    roles jsonb, -- Stores an array of Discord role objects
    highest_role jsonb, -- Stores the single highest Discord role object
    last_synced_at timestamptz,
    is_banned boolean default false,
    ban_reason text,
    ban_expires_at timestamptz
);


-- Table for store products.
create table if not exists public.products (
    id uuid primary key default gen_random_uuid(),
    nameKey text not null,
    descriptionKey text,
    price numeric(10, 2) not null,
    imageUrl text
);


-- Table for quiz/application forms.
create table if not exists public.quizzes (
    id uuid primary key default gen_random_uuid(),
    titleKey text not null,
    descriptionKey text,
    questions jsonb, -- Stores an array of question objects
    isOpen boolean default false,
    created_at timestamptz default now(),
    allowedTakeRoles text[], -- Array of Discord Role IDs that can handle these submissions
    logoUrl text,
    bannerUrl text,
    lastOpenedAt timestamptz -- Used to check for submissions within the current "season"
);


-- Table for user submissions to quizzes.
create table if not exists public.submissions (
    id uuid primary key default gen_random_uuid(),
    quizId uuid references public.quizzes(id) on delete set null,
    quizTitle text,
    user_id uuid references auth.users(id) on delete cascade not null,
    username text,
    answers jsonb,
    submittedAt timestamptz default now(),
    status text default 'pending', -- pending, taken, accepted, refused
    adminId uuid references auth.users(id) on delete set null,
    adminUsername text,
    updatedAt timestamptz, -- Tracks when the status was last changed
    cheatAttempts jsonb, -- Stores log of anti-cheat triggers
    user_highest_role text
);


-- Table for server rules, organized by categories.
create table if not exists public.rules (
    id uuid primary key default gen_random_uuid(),
    titleKey text not null,
    position int not null,
    rules jsonb -- Array of rule objects [{id, textKey}, ...]
);


-- Table for audit logs of admin actions.
create table if not exists public.audit_log (
    id bigint generated by default as identity primary key,
    timestamp timestamptz default now(),
    admin_id uuid references auth.users(id),
    admin_username text,
    action text
);


-- Table to map Discord role IDs to website permissions.
create table if not exists public.role_permissions (
    role_id text primary key,
    permissions text[] -- Array of permission keys
);


-- Table for website translations, allowing admin panel management.
create table if not exists public.translations (
    key text primary key,
    en text,
    ar text
);

-- Table for user bans.
create table if not exists public.bans (
    id uuid primary key default gen_random_uuid(),
    user_id uuid not null references auth.users(id) on delete cascade,
    banned_by uuid references auth.users(id) on delete set null,
    reason text,
    expires_at timestamptz, -- Null for permanent bans
    created_at timestamptz default now(),
    unbanned_by uuid references auth.users(id) on delete set null,
    unbanned_at timestamptz,
    is_active boolean default true
);


-- =================================================================
-- 3. ROW LEVEL SECURITY (RLS) POLICIES
-- =================================================================

-- Function to get the current authenticated user's ID.
create or replace function auth.get_user_id()
returns uuid
language sql stable
as $$
  select nullif(current_setting('request.jwt.claim.sub', true), '')::uuid;
$$;

-- Enable RLS on all tables that contain user or sensitive data.
alter table public.config enable row level security;
alter table public.profiles enable row level security;
alter table public.products enable row level security;
alter table public.quizzes enable row level security;
alter table public.submissions enable row level security;
alter table public.rules enable row level security;
alter table public.audit_log enable row level security;
alter table public.role_permissions enable row level security;
alter table public.translations enable row level security;
alter table public.bans enable row level security;

-- Clear existing policies before creating new ones.
drop policy if exists "Allow public read access" on public.config;
drop policy if exists "Allow authenticated users to read their own profile" on public.profiles;
drop policy if exists "Allow public read access to products" on public.products;
drop policy if exists "Allow public read access to quizzes" on public.quizzes;
drop policy if exists "Allow users to see their own submissions" on public.submissions;
drop policy if exists "Allow public read access to rules" on public.rules;
drop policy if exists "Allow public read access to translations" on public.translations;

-- Create POLICIES for public read access.
create policy "Allow public read access" on public.config for select using (true);
create policy "Allow public read access to products" on public.products for select using (true);
create policy "Allow public read access to quizzes" on public.quizzes for select using (true);
create policy "Allow public read access to rules" on public.rules for select using (true);
create policy "Allow public read access to translations" on public.translations for select using (true);

-- Create POLICIES for user-specific data access.
create policy "Allow authenticated users to read their own profile" on public.profiles for select
  using (id = auth.get_user_id());
create policy "Allow users to see their own submissions" on public.submissions for select
  using (user_id = auth.get_user_id());

-- NOTE: Admin access is handled by RPC functions which run with the 'service_role' key, bypassing RLS.
-- This is a secure pattern as all admin logic is centralized in the database functions.

-- =================================================================
-- 4. HELPER & PERMISSION FUNCTIONS
-- =================================================================

-- Function to check if a user has a specific permission.
create or replace function public.has_permission(p_user_id uuid, p_permission_key text)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  user_roles text[];
  has_perm boolean;
begin
  -- Get the user's role IDs from their profile
  select array(select jsonb_array_elements_text(roles->'roles'))
  into user_roles
  from public.profiles
  where id = p_user_id;

  if user_roles is null or array_length(user_roles, 1) is null then
    return false;
  end if;

  -- Check if any of the user's roles have the '_super_admin' permission
  select exists (
    select 1
    from public.role_permissions
    where role_id = any(user_roles) and '_super_admin' = any(permissions)
  ) into has_perm;

  if has_perm then
    return true;
  end if;

  -- If not a super admin, check for the specific permission
  select exists (
    select 1
    from public.role_permissions
    where role_id = any(user_roles) and p_permission_key = any(permissions)
  ) into has_perm;

  return has_perm;
end;
$$;


-- =================================================================
-- 5. REMOTE PROCEDURE CALLS (RPC) - MAIN API LOGIC
-- =================================================================

-- Get site configuration.
create or replace function public.get_config()
returns json
language sql stable
as $$
  select row_to_json(c) from public.config c where id = 1;
$$;

-- Get all submissions (Admin Only).
create or replace function public.get_all_submissions()
returns setof public.submissions
language plpgsql
as $$
begin
  if not public.has_permission(auth.get_user_id(), 'admin_submissions') then
    raise exception 'Insufficient permissions';
  end if;
  return query select * from public.submissions order by submittedAt desc;
end;
$$;


-- Add a new submission.
create or replace function public.add_submission(submission_data jsonb)
returns public.submissions
language plpgsql
as $$
declare
  new_submission public.submissions;
  notification_payload jsonb;
begin
  insert into public.submissions (quizId, quizTitle, user_id, username, answers, cheatAttempts, user_highest_role)
  values (
    (submission_data->>'quizId')::uuid,
    submission_data->>'quizTitle',
    (submission_data->>'user_id')::uuid,
    submission_data->>'username',
    submission_data->'answers',
    submission_data->'cheatAttempts',
    submission_data->>'user_highest_role'
  ) returning * into new_submission;

  -- Trigger notification for new submission
  select extensions.http_post(
    (select value from private.get_secret('VITE_SUPABASE_FUNCTIONS_URL') || '/discord-proxy'),
    jsonb_build_object(
      'type', 'new_submission',
      'payload', jsonb_build_object(
        'submissionId', new_submission.id,
        'username', new_submission.username,
        'quizTitle', new_submission.quizTitle,
        'timestamp', new_submission.submittedAt
      )
    ),
    'application/json'
  );

  return new_submission;
end;
$$;


-- Update submission status (Admin Only).
create or replace function public.update_submission_status(p_submission_id uuid, p_new_status text)
returns void
language plpgsql security definer
as $$
declare
  submission_owner_id uuid;
  submission_username text;
  submission_quiz_title text;
  admin_user record;
begin
  if not public.has_permission(auth.get_user_id(), 'admin_submissions') then
    raise exception 'Insufficient permissions';
  end if;

  select id, raw_user_meta_data->>'full_name' as username into admin_user from auth.users where id = auth.get_user_id();

  update public.submissions
  set
    status = p_new_status,
    adminId = auth.get_user_id(),
    adminUsername = admin_user.username,
    updatedAt = now()
  where id = p_submission_id
  returning user_id, username, quizTitle into submission_owner_id, submission_username, submission_quiz_title;
  
  -- Trigger notification for status update (DM to user)
  perform extensions.http_post(
    (select value from private.get_secret('VITE_SUPABASE_FUNCTIONS_URL') || '/discord-proxy'),
    jsonb_build_object(
      'type', 'submission_result',
      'payload', jsonb_build_object(
        'userId', submission_owner_id,
        'username', submission_username,
        'quizTitle', submission_quiz_title,
        'status', p_new_status,
        'adminUsername', admin_user.username,
        'timestamp', now()
      )
    ),
    'application/json'
  );

end;
$$;


-- Save a quiz (create or update) (Admin Only).
create or replace function public.save_quiz(quiz_data jsonb)
returns public.quizzes
language plpgsql
as $$
declare
  result public.quizzes;
  q_id uuid;
begin
  if not public.has_permission(auth.get_user_id(), 'admin_quizzes') then
    raise exception 'Insufficient permissions';
  end if;

  q_id := (quiz_data->>'id')::uuid;

  insert into public.quizzes (id, titleKey, descriptionKey, questions, isOpen, allowedTakeRoles, logoUrl, bannerUrl, lastOpenedAt)
  values (
    coalesce(q_id, gen_random_uuid()),
    quiz_data->>'titleKey',
    quiz_data->>'descriptionKey',
    quiz_data->'questions',
    (quiz_data->>'isOpen')::boolean,
    (select array_agg(elem) from jsonb_array_elements_text(quiz_data->'allowedTakeRoles') as elem),
    quiz_data->>'logoUrl',
    quiz_data->>'bannerUrl',
    case when (quiz_data->>'isOpen')::boolean and not exists (select 1 from quizzes where id=q_id and isOpen=true)
         then now()
         else (select lastOpenedAt from quizzes where id=q_id)
    end
  )
  on conflict (id) do update set
    titleKey = excluded.titleKey,
    descriptionKey = excluded.descriptionKey,
    questions = excluded.questions,
    isOpen = excluded.isOpen,
    allowedTakeRoles = excluded.allowedTakeRoles,
    logoUrl = excluded.logoUrl,
    bannerUrl = excluded.bannerUrl,
    lastOpenedAt = case when excluded.isOpen and not quizzes.isOpen
                        then now()
                        else quizzes.lastOpenedAt
                   end
  returning * into result;

  return result;
end;
$$;


-- Save all rules (Admin Only).
create or replace function public.save_rules(rules_data jsonb)
returns void
language plpgsql
as $$
begin
  if not public.has_permission(auth.get_user_id(), 'admin_rules') then
    raise exception 'Insufficient permissions';
  end if;
  
  -- Simple approach: delete all and insert new. Good for full state updates.
  truncate table public.rules;
  
  insert into public.rules (id, titleKey, position, rules)
  select
    (value->>'id')::uuid,
    value->>'titleKey',
    (value->>'position')::int,
    value->'rules'
  from jsonb_array_elements(rules_data);
end;
$$;


-- Update site configuration (Admin Only).
create or replace function public.update_config(new_config jsonb)
returns void
language plpgsql
as $$
begin
  if not public.has_permission(auth.get_user_id(), 'admin_appearance') then
    raise exception 'Insufficient permissions';
  end if;

  update public.config
  set
    "COMMUNITY_NAME" = coalesce(new_config->>'COMMUNITY_NAME', "COMMUNITY_NAME"),
    "LOGO_URL" = coalesce(new_config->>'LOGO_URL', "LOGO_URL"),
    "DISCORD_GUILD_ID" = coalesce(new_config->>'DISCORD_GUILD_ID', "DISCORD_GUILD_ID"),
    "DISCORD_INVITE_URL" = coalesce(new_config->>'DISCORD_INVITE_URL', "DISCORD_INVITE_URL"),
    "MTA_SERVER_URL" = coalesce(new_config->>'MTA_SERVER_URL', "MTA_SERVER_URL"),
    "BACKGROUND_IMAGE_URL" = coalesce(new_config->>'BACKGROUND_IMAGE_URL', "BACKGROUND_IMAGE_URL"),
    "SHOW_HEALTH_CHECK" = coalesce((new_config->>'SHOW_HEALTH_CHECK')::boolean, "SHOW_HEALTH_CHECK"),
    "SUBMISSIONS_CHANNEL_ID" = coalesce(new_config->>'SUBMISSIONS_CHANNEL_ID', "SUBMISSIONS_CHANNEL_ID"),
    "AUDIT_LOG_CHANNEL_ID" = coalesce(new_config->>'AUDIT_LOG_CHANNEL_ID', "AUDIT_LOG_CHANNEL_ID")
  where id = 1;
end;
$$;

-- Log an admin action.
create or replace function public.log_action(p_action text)
returns void
language plpgsql security definer
as $$
declare
  admin_user record;
begin
  select id, raw_user_meta_data->>'full_name' as username into admin_user
  from auth.users where id = auth.get_user_id();

  insert into public.audit_log(admin_id, admin_username, action)
  values (admin_user.id, admin_user.username, p_action);

  -- Trigger audit log notification
  perform extensions.http_post(
    (select value from private.get_secret('VITE_SUPABASE_FUNCTIONS_URL') || '/discord-proxy'),
    jsonb_build_object(
      'type', 'audit_log',
      'payload', jsonb_build_object(
        'adminUsername', admin_user.username,
        'action', p_action,
        'timestamp', now()
      )
    ),
    'application/json'
  );
end;
$$;


-- Ban a user (Admin Only)
create or replace function public.ban_user(p_target_user_id uuid, p_reason text, p_duration_hours int)
returns void
language plpgsql security definer
as $$
declare
  v_expires_at timestamptz;
  target_username text;
begin
  if not public.has_permission(auth.get_user_id(), 'admin_lookup') then
    raise exception 'Insufficient permissions';
  end if;

  if p_duration_hours is not null then
    v_expires_at := now() + (p_duration_hours * interval '1 hour');
  else
    v_expires_at := null; -- Permanent ban
  end if;
  
  -- Update profile
  update public.profiles
  set is_banned = true,
      ban_reason = p_reason,
      ban_expires_at = v_expires_at
  where id = p_target_user_id;

  -- Deactivate previous active bans for this user
  update public.bans set is_active = false where user_id = p_target_user_id and is_active = true;

  -- Create a new ban record
  insert into public.bans(user_id, banned_by, reason, expires_at, is_active)
  values (p_target_user_id, auth.get_user_id(), p_reason, v_expires_at, true);

  -- Log action
  select raw_user_meta_data->>'global_name' from auth.users where id = p_target_user_id into target_username;
  perform public.log_action('Banned user ' || coalesce(target_username, p_target_user_id::text) || ' for reason: ' || p_reason);
end;
$$;


-- Unban a user (Admin Only)
create or replace function public.unban_user(p_target_user_id uuid)
returns void
language plpgsql security definer
as $$
declare
  target_username text;
begin
  if not public.has_permission(auth.get_user_id(), 'admin_lookup') then
    raise exception 'Insufficient permissions';
  end if;

  -- Update profile
  update public.profiles
  set is_banned = false,
      ban_reason = null,
      ban_expires_at = null
  where id = p_target_user_id;

  -- Deactivate ban record
  update public.bans
  set is_active = false,
      unbanned_by = auth.get_user_id(),
      unbanned_at = now()
  where user_id = p_target_user_id and is_active = true;
  
  -- Log action
  select raw_user_meta_data->>'global_name' from auth.users where id = p_target_user_id into target_username;
  perform public.log_action('Unbanned user ' || coalesce(target_username, p_target_user_id::text));
end;
$$;


-- Create a private schema to store secrets.
create schema if not exists private;

-- Create a table to store secrets.
create table if not exists private.secrets (
  key text primary key,
  value text not null
);

-- Revoke all permissions from public for the secrets table.
revoke all on table private.secrets from public;

-- Function to securely get a secret.
create or replace function private.get_secret(secret_key text)
returns text
language plpgsql
as $$
declare
  secret_value text;
begin
  select value into secret_value from private.secrets where key = secret_key;
  return secret_value;
end;
$$;

-- =================================================================
-- 6. FUNCTION OWNERSHIP & PERMISSIONS FIX (V2 - ROBUST)
-- =================================================================
-- This block fixes the "permission denied for schema auth" error by temporarily
-- elevating the script's execution role to one that can modify and own functions
-- that need to access the auth schema. This is a secure and robust solution.

DO $$
BEGIN
  -- Grant the ability to change roles to the current user (postgres)
  GRANT supabase_auth_admin TO postgres;

  -- Temporarily switch to the auth admin role to perform ownership changes
  SET ROLE supabase_auth_admin;

  -- Functions that need to read user metadata (like username) from auth.users
  -- must be owned by a role that has permission to do so.
  ALTER FUNCTION public.update_submission_status(uuid, text) OWNER TO supabase_auth_admin;
  ALTER FUNCTION public.log_action(text) OWNER TO supabase_auth_admin;
  ALTER FUNCTION public.ban_user(uuid, text, int) OWNER TO supabase_auth_admin;
  ALTER FUNCTION public.unban_user(uuid) OWNER TO supabase_auth_admin;
  ALTER FUNCTION public.has_permission(uuid, text) OWNER TO supabase_auth_admin;

  -- Revert back to the original role
  RESET ROLE;

  -- Clean up by revoking the role change permission
  REVOKE supabase_auth_admin FROM postgres;
END;
$$;


-- =================================================================
-- 7. FINALIZATION
-- =================================================================
grant usage on schema public to postgres, anon, authenticated, service_role;
grant all privileges on all tables in schema public to postgres, anon, authenticated, service_role;
grant all privileges on all functions in schema public to postgres, anon, authenticated, service_role;
grant all privileges on all sequences in schema public to postgres, anon, authenticated, service_role;

alter user supabase_admin with superuser;

-- The schema is now complete.
`;
